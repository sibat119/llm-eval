{
    "wrt_gt": {
        "exact_match": 0.0,
        "f1_score_token_agreement": 0.07387963661792059,
        "f1_score_ranking": 0.4351522273261404,
        "accuracy_ranking": 0.45,
        "rouge_scores": {
            "rouge1": 0.14120602692466155,
            "rouge2": 0.03365550549308001,
            "rougeL": 0.12157652545683542
        },
        "bleu_score": 0.006873706842735619,
        "sbert_similarity": 0.40147592600435017,
        "agreement_without_mind_model": {
            "agreement_score": 0.71,
            "model_ground_truth_match": 0.84,
            "blackbox_ground_truth_match": 0.7,
            "both_ground_truth_match": 0.64,
            "agreement_samples": [
                {
                    "model_output": "Yes",
                    "blackbox_output": "Yes.",
                    "ground_truth": "Yes",
                    "options": "['Yes', 'No', \"It's machine-dependent\", 'None of the above']"
                },
                {
                    "model_output": "8",
                    "blackbox_output": "8",
                    "ground_truth": "8",
                    "options": "['1', '3', '8', '16']"
                },
                {
                    "model_output": "Both algorithms work correctly on all input values.",
                    "blackbox_output": "Both algorithms work correctly on all input values.",
                    "ground_truth": "Neither algorithm will correctly identify the maximum value when the input contains both positive and negative input values.",
                    "options": "['Both algorithms work correctly on all input values.', 'Algorithm I always works correctly, but Algorithm II only works correctly when the maximum value is not the first value in the list.', 'Algorithm II always works correctly, but Algorithm I only works correctly when the maximum value is greater than or equal to -l.', 'Neither algorithm will correctly identify the maximum value when the input contains both positive and negative input values.']"
                },
                {
                    "model_output": "255",
                    "blackbox_output": "255.",
                    "ground_truth": "255",
                    "options": "['32', '225', '255', '256']"
                },
                {
                    "model_output": "seed([x])",
                    "blackbox_output": "seed([x])",
                    "ground_truth": "seed([x])",
                    "options": "['choice(seq)', 'randrange ([start,] stop [,step])', 'random()', 'seed([x])']"
                },
                {
                    "model_output": "A school provides a laptop or tablet computer to all students enrolled at the school.",
                    "blackbox_output": "A school provides a laptop or tablet computer to all students enrolled at the school.",
                    "ground_truth": "A school provides a laptop or tablet computer to all students enrolled at the school.",
                    "options": "['A school allows students to bring a graphing calculator from home to complete in-class mathematics assignments.', 'A school allows students to bring a tablet computer to class every day to participate in graded quizzes.', 'A school provides a laptop or tablet computer to all students enrolled at the school.', 'A school recommends that all students purchase a computer with as much processing speed as possible so that projects run faster.']"
                },
                {
                    "model_output": "Perform real-world experiments on the plant species' growth in different environments. Compare the experimental results to the results provided by the simulation.",
                    "blackbox_output": "Perform real-world experiments on the plant species' growth in different environments. Compare the experimental results to the results provided by the simulation.",
                    "ground_truth": "Perform real-world experiments on the plant species' growth in different environments. Compare the experimental results to the results provided by the simulation.",
                    "options": "['Express the simulation software using both recursive and iterative algorithms. Compare the results of the recursive algorithm to those of the iterative algorithm.', \"Perform real-world experiments on the plant species' growth in different environments. Compare the experimental results to the results provided by the simulation.\", 'Remove any unnecessary details from the model. Compare the running times of the original simulation and the simplified simulation.', 'Run the simulation software on multiple devices. Compare the results obtained from each of the devices.']"
                },
                {
                    "model_output": "24",
                    "blackbox_output": "24.",
                    "ground_truth": "24",
                    "options": "['8', '16', '24', '32']"
                },
                {
                    "model_output": "Translating a program written in an abstract, high-level language into a program with the same behavior expressed in machine code.",
                    "blackbox_output": "Translating a program written in an abstract, high-level language into a program with the same behavior expressed in machine code.",
                    "ground_truth": "Translating a program written in an abstract, high-level language into a program with the same behavior expressed in machine code",
                    "options": "['Managing specification files created as part of the development process', 'Running and testing the executable created by the programmer', 'Tracking older versions of the software in case an error is found and the software needs to be reverted to an earlier form', 'Translating a program written in an abstract, high-level language into a program with the same behavior expressed in machine code']"
                },
                {
                    "model_output": "isupper()",
                    "blackbox_output": "isupper()",
                    "ground_truth": "isupper()",
                    "options": "['isupper()', 'join(seq)', 'len(string)', 'ljust(width[, fillchar])']"
                }
            ],
            "disagreement_samples": [
                {
                    "model_output": "Error",
                    "blackbox_output": "abcd",
                    "ground_truth": "abcd",
                    "options": "[\"( 'abcd', 786 , 2.23, 'john', 70.2 )\", 'abcd', 'Error', 'None of the above.']"
                },
                {
                    "model_output": "Changing line 3 to b \u2190 10",
                    "blackbox_output": "Changing line 7 to a \u2190 b + 10. \n\nThis is because the condition in the IF statement is a = 0, and changing line 7 to a \u2190 b + 10 does not affect the value of 'a' when the condition is true or false, it only changes the value of 'a' inside the ELSE block, but the ELSE block is not executed when the condition is true.",
                    "ground_truth": "Changing line 3 to b \u2190 10",
                    "options": "['Changing line 3 to b \u2190 10', 'Changing line 3 to a \u2190 b + 10', 'Changing line 7 to b \u2190 20', 'Changing line 7 to a \u2190 b + 10']"
                },
                {
                    "model_output": "The specification should be modified to indicate what should be done if there is more than one index of larger values.",
                    "blackbox_output": "The method should be written so as to return the index of every occurrence of a larger value. This is because the problem specification does not indicate what should be done if there are multiple values larger than the given item, and returning all indices is a reasonable and useful default behavior.",
                    "ground_truth": "The specification should be modified to indicate what should be done if there is more than one index of larger values.",
                    "options": "['The method should be written on the assumption that there is only one value in the array that is larger than the given item.', 'The method should be written so as to return the index of every occurrence of a larger value.', 'The specification should be modified to indicate what should be done if there is more than one index of larger values.', 'The method should be written to output a message if more than one larger value is found.']"
                },
                {
                    "model_output": "A function that sorts values in a column or row.",
                    "blackbox_output": "A function that averages numeric values in a column or row. This function would allow you to identify values that are significantly higher or lower than the average, indicating potential data entry errors.",
                    "ground_truth": "A function that sorts values in a column or row",
                    "options": "['A function that averages numeric values in a column or row', 'A function that counts the values in a column or row', 'A function that rounds a numeric value', 'A function that sorts values in a column or row']"
                },
                {
                    "model_output": "II and III only",
                    "blackbox_output": "I and III only.",
                    "ground_truth": "II and III only",
                    "options": "['II only', 'I and II only', 'I and III only', 'II and III only']"
                },
                {
                    "model_output": "The company will be able to provide a human representative for any incoming call.",
                    "blackbox_output": "Customers are likely to spend less time listening to information not relevant to their issue.",
                    "ground_truth": "The company will be able to provide a human representative for any incoming call.",
                    "options": "['Human representatives will not be needed to respond to some inquiries.', 'The company will be able to provide a human representative for any incoming call.', 'Customers are likely to spend less time listening to information not relevant to their issue.', 'Customers will be unable to mistakenly select the incorrect department for their particular issue.']"
                },
                {
                    "model_output": "The simulation will not produce usable results because actual customer data are not available.",
                    "blackbox_output": "The bank can use the simulation to investigate these two options without causing inconvenience for customers.",
                    "ground_truth": "The simulation will not produce usable results because actual customer data are not available.",
                    "options": "['The bank can incorporate other factors, such as the number of tellers, in the simulation.', 'The bank can use the simulation to investigate these two options without causing inconvenience for customers.', 'The bank may consider new alternatives based on the simulation results.', 'The simulation will not produce usable results because actual customer data are not available.']"
                },
                {
                    "model_output": "Which items listed in the database are not currently in the store",
                    "blackbox_output": "The total number of shoes sold in a particular month cannot be determined from the database, as it does not contain any sales data.",
                    "ground_truth": "Which items listed in the database are not currently in the store",
                    "options": "['Which items listed in the database are not currently in the store', 'Which colors are more popular among men than women', 'Which type of footwear is most popular among adults', 'The total number of shoes sold in a particular month']"
                },
                {
                    "model_output": "10",
                    "blackbox_output": "250. \n\nIn a binary search, the list is divided in half at each step, so the maximum number of elements examined is the height of a binary tree with 500 elements. The height of a binary tree with n elements is log2(n), so for 500 elements, it's approximately log2(500), which is roughly 8.965. Since we can't examine a fraction of an element, we round up to the nearest whole number, but in this case, we're looking for the closest answer, and 250 is the closest integer to 8.965 * 50 (since each level of the tree is roughly twice the previous one).",
                    "ground_truth": "10",
                    "options": "['10', '50', '250', '500']"
                },
                {
                    "model_output": "Both of the above.",
                    "blackbox_output": "It supports automatic garbage collection and can be easily integrated with C, C++, COM, ActiveX, CORBA, and Java.",
                    "ground_truth": "Both of the above.",
                    "options": "['It supports automatic garbage collection.', 'It can be easily integrated with C, C++, COM, ActiveX, CORBA, and Java.', 'Both of the above.', 'None of the above.']"
                }
            ]
        },
        "agreement_after_mind_model": {
            "agreement_score": 0.54,
            "model_ground_truth_match": 0.45,
            "blackbox_ground_truth_match": 0.7,
            "both_ground_truth_match": 0.41,
            "agreement_samples": [
                {
                    "model_output": "Predicted Response: \"Online newspapers typically offer more in-depth and comprehensive articles compared to the often brief and fragmented content found on social media sites.\"",
                    "blackbox_output": "The ability to provide credibility to the information distributed.",
                    "ground_truth": "The ability to provide credibility to the information distributed",
                    "options": "['The ability to distribute information instantaneously', 'The ability to provide credibility to the information distributed', 'The ability to provide information that is widely accessible', 'The ability to provide media-rich content for low cost']"
                },
                {
                    "model_output": "To satisfy the postcondition that the method `nextIntInRange` returns a random integer in the range from `low` to `high`, inclusive, the expression within the method should generate a random integer within that specified range. Given Java's standard library, the most common way to achieve this is by using the `java.util.Random` class.\n\nThe predicted response from the black-box model would likely be:\n\n```plaintext\nThe expression should be: (int)(Math.random() * (high - low + 1)) + low.\nThis ensures that the generated integer is within the inclusive range from low to high. Math.random() generates a random double between 0.0 (inclusive) and 1.0 (exclusive), multiplying it by (high - low + 1) scales it to the desired range, and adding low shifts the range to start at low. Casting to int truncates the decimal part, effectively rounding down to the nearest integer, which is appropriate for generating integers.\n```\n\nThis response aligns with the typical approach used in Java for generating random integers within a specified range.",
                    "blackbox_output": "(int) (Math.random() * (high - low + 1)) + low;",
                    "ground_truth": "(int) (Math.random() * (high - low + 1)) + low;",
                    "options": "['(int) (Math.random() * high) + low;', '(int) (Math.random() * (high - low)) + low;', '(int) (Math.random() * (high - low + 1)) + low;', '(int) (Math.random() * (high + low)) + low;']"
                },
                {
                    "model_output": "\"Which type of footwear is selling at the highest price?\"\n\nThis question can be directly answered by analyzing the selling price and footwear type from the provided database information. The other options might not be as straightforward or may require additional assumptions or calculations that aren't directly supported by the given data fields.",
                    "blackbox_output": "The total number of shoes sold in a particular month cannot be determined from the database, as it does not contain any sales data.",
                    "ground_truth": "Which items listed in the database are not currently in the store",
                    "options": "['Which items listed in the database are not currently in the store', 'Which colors are more popular among men than women', 'Which type of footwear is most popular among adults', 'The total number of shoes sold in a particular month']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question \"Which of the following best explains how data is typically assembled in packets for transmission over the Internet?\" would be:\n\n\"The data is broken down into smaller segments or packets for efficient transmission, and these packets are reassembled at the destination.\"\n\nThis prediction is based on the pattern observed in the previous examples where the black-box model provided explanations related to packetization and reassembly processes in network communications.",
                    "blackbox_output": "Each packet contains data to be transmitted, along with metadata containing information used for routing the data.",
                    "ground_truth": "Each packet contains data to be transmitted, along with metadata containing information used for routing the data.",
                    "options": "['Each packet contains data to be transmitted, along with metadata containing information used for routing the data.', 'Each packet contains an encrypted version of the data to be transmitted, along with metadata containing the key needed to decrypt the data.', 'Each packet contains only the metadata used to establish a direct connection so that the data can be transmitted.', 'Each packet contains multiple data files bundled together, along with metadata describing how to categorize each data file.']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question \"In Python 3, what is ['a', 'Chemistry', 0, 1][1]? \" is:\n\n\"Chemistry\"\n\nThis prediction is based on the pattern observed in the examples provided, where the index access operation returns the element at the specified position in the list. In this case, accessing the second element (index 1) of the list `['a', 'Chemistry', 0, 1]` would return `'Chemistry'`.",
                    "blackbox_output": "Chemistry",
                    "ground_truth": "Chemistry",
                    "options": "['a', 'Chemistry', '0', '1']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question would be:\n\nResponse: \"'abcd'\"\n\nThis prediction is based on the pattern observed in the examples provided, where the black-box model returns the element at the specified index from the given collection (list or tuple). In this case, `tuple[0]` would return the first element of the tuple, which is a string `'abcd'`.",
                    "blackbox_output": "abcd",
                    "ground_truth": "abcd",
                    "options": "[\"( 'abcd', 786 , 2.23, 'john', 70.2 )\", 'abcd', 'Error', 'None of the above.']"
                },
                {
                    "model_output": "\"O(n) is the largest asymptotically.\"\n\nThis prediction is based on the pattern observed in the examples provided, where the black-box model responds with the relevant Big O notation for the given question about asymptotic behavior.",
                    "blackbox_output": "O(n^2) is the largest asymptotically.",
                    "ground_truth": "O(n^2)",
                    "options": "['O(1)', 'O(n)', 'O(n^2)', 'O(log n)']"
                },
                {
                    "model_output": "Predicted Response: '0'\n\nExplanation: Based on the examples provided, when using negative indexing, it counts from the end of the list. In the new question, `['a', 'Chemistry', 0, 1][-3]` refers to the third element counting from the end, which is '0'.",
                    "blackbox_output": "0",
                    "ground_truth": "Chemistry",
                    "options": "['a', 'Chemistry', '0', '1']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question is:\n\n\"Which state has the highest number of computer science majors based on the data provided?\"\n\nThis prediction is based on the structure of the previous examples, where the questions typically involve analyzing specific attributes within the given dataset to draw conclusions or make determinations. The new question provides information about the dataset and asks which question could be answered by analyzing only the information contained within it. The response suggests a question that directly relates to the data attributes provided (student's state of attendance).",
                    "blackbox_output": "What percent of students attending college in a certain state are majoring in computer science.",
                    "ground_truth": "How many states have a higher percentage of female computer science majors than male computer science majors attending college in that state?",
                    "options": "['Do students majoring in computer science tend to have higher grade point averages than students majoring in other subjects?', 'How many states have a higher percentage of female computer science majors than male computer science majors attending college in that state?', 'What percent of students attending college in a certain state are majoring in computer science?', 'Which college has the highest number of students majoring in computer science?']"
                },
                {
                    "model_output": "\"Program documentation is essential for maintaining clarity and understanding of the program, especially for future maintenance and collaboration among developers. It helps in explaining the purpose of the program, describing the algorithms used, detailing the input and output requirements, and providing examples of how to use the program effectively.\"",
                    "blackbox_output": "Program documentation is useful during initial program development and also when modifications are made to existing programs.",
                    "ground_truth": "Program documentation is useful during initial program development and also when modifications are made to existing programs.",
                    "options": "['Program documentation should not be changed after it is first written.', 'Program documentation is only needed for programs in development; it is not needed after a program is completed.', 'Program documentation is useful when programmers collaborate but not when a programmer works individually on a project.', 'Program documentation is useful during initial program development and also when modifications are made to existing programs.']"
                }
            ],
            "disagreement_samples": [
                {
                    "model_output": "\"Generally, the number of data movements required to sort the list increases with the size of the list.\"",
                    "blackbox_output": "The number of comparisons for insertion sort is independent of the initial arrangement of elements.",
                    "ground_truth": "The number of comparisons for selection sort is independent of the initial arrangement of elements.",
                    "options": "['If the array is initially sorted in descending order, then insertion sort will be more efficient than selection sort.', 'The number of comparisons for selection sort is independent of the initial arrangement of elements.', 'The number of comparisons for insertion sort is independent of the initial arrangement of elements.', 'The number of data movements in selection sort depends on the initial arrangement of elements.']"
                },
                {
                    "model_output": "Predicted Response: \"{1, 2, 3, 4}\"\n\nExplanation: The `set` function in Python creates an unordered collection of unique elements. Given the list `l = [1,2,2,3,4]`, converting it to a set will remove the duplicate `2`, resulting in the set `{1, 2, 3, 4}`.",
                    "blackbox_output": "{1,2,3,4}",
                    "ground_truth": "{1,2,3,4}",
                    "options": "['{1}', '{1,2,2,3,4}', '{1,2,3,4}', '{4,3,2,2,1}']"
                },
                {
                    "model_output": "Predicted Response: \"255.\"\n\nExplanation: In hexadecimal, a two-digit number ranges from 00 to FF. The largest two-digit hexadecimal number is FF, which represents \\(15 \\times 16^1 + 15 \\times 16^0 = 240 + 15 = 255\\) in base-10. Therefore, the largest base-10 integer that can be represented with a two-digit hexadecimal number is 255.",
                    "blackbox_output": "255.",
                    "ground_truth": "255",
                    "options": "['32', '225', '255', '256']"
                },
                {
                    "model_output": "Predicted Response: \"4\"",
                    "blackbox_output": "8 >> 1 is 4.",
                    "ground_truth": "4",
                    "options": "['3', '4', '2', '8']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question is likely to be:\n\n\"Both Algorithm I and Algorithm II will correctly identify the maximum value in the list of integers. However, Algorithm II is more efficient because it starts by setting the initial value of `max` to the first element in the list, whereas Algorithm I sets `max` to -1. This means that Algorithm I will need to compare the first element with -1 before starting the iteration, which is unnecessary since the first element is guaranteed to be greater than -1. Therefore, Algorithm II avoids this extra comparison and can start the iteration directly, making it slightly more efficient.\"\n\nThis response aligns with the pattern of explaining the behavior and efficiency differences between the provided algorithms based on their implementations.",
                    "blackbox_output": "Both algorithms work correctly on all input values.",
                    "ground_truth": "Neither algorithm will correctly identify the maximum value when the input contains both positive and negative input values.",
                    "options": "['Both algorithms work correctly on all input values.', 'Algorithm I always works correctly, but Algorithm II only works correctly when the maximum value is not the first value in the list.', 'Algorithm II always works correctly, but Algorithm I only works correctly when the maximum value is greater than or equal to -l.', 'Neither algorithm will correctly identify the maximum value when the input contains both positive and negative input values.']"
                },
                {
                    "model_output": "\"Which of the following questions is LEAST likely to be answerable using the trends feature?\"\n\nPredicted Response: \"What is the exact number of searches made by individual users in a specific region during a specific date range?\"\n\nThis prediction is based on the pattern in the provided examples where the black-box model often focuses on the feasibility or practicality of answering specific questions given the constraints of the provided data. In this case, the exact number of searches per user would require individual-level data, which is not typically available through a trend-tracking feature that aggregates data by region, date, and category.",
                    "blackbox_output": "In what is the cost of a certain electronics product?",
                    "ground_truth": "What is the cost of a certain electronics product?",
                    "options": "['In what month does a particular sport receive the most searches?', 'In which political candidates are people interested?', 'What is the cost of a certain electronics product?', 'Which region of the country has the greatest number of people searching for opera performances?']"
                },
                {
                    "model_output": "Predicted Response: `a[i] == max`\n\nExplanation: The given boolean expression `a[i] == max || !(max != a[i])` can be simplified by understanding the logical operations involved. \n\n- `!(max != a[i])` is equivalent to saying `max == a[i]`, because the negation of inequality (`!=`) is equality (`==`).\n\nSo, the expression becomes:\n- `a[i] == max || max == a[i]`\n\nSince both parts of the OR operation are the same, they simplify to just `a[i] == max`.",
                    "blackbox_output": "a[i] == max",
                    "ground_truth": "a[i] == max",
                    "options": "['a[i] == max', 'a[i] != max', 'a[i] < max || a[i] > max', 'FALSE']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question is likely to be:\n\n\"The error will be detected when the program attempts to divide by zero, which will cause a runtime error or exception. Specifically, if N is zero, attempting to calculate the average using the formula `average = sum / N` will result in a division by zero error, as division by zero is undefined in most programming languages. This error will typically be caught by the program's error handling mechanisms or result in the program crashing, depending on how the language handles such exceptions.\"\n\nThis response aligns with the pattern of explaining potential issues and their detection in the provided examples.",
                    "blackbox_output": "During run time.",
                    "ground_truth": "During run time",
                    "options": "['At compile time', 'At edit time', 'As soon as the value of N is entered', 'During run time']"
                },
                {
                    "model_output": "The predicted response from the black-box model to the new question would be:\n\n\"(age \u2265 16) AND (NOT(age \u2265 18))\"\n\nThis expression correctly evaluates to true if the person is old enough to drive (at least 16 years old) but not old enough to vote (less than 18 years old), and evaluates to false otherwise.",
                    "blackbox_output": "I and III only.",
                    "ground_truth": "II and III only",
                    "options": "['II only', 'I and II only', 'I and III only', 'II and III only']"
                },
                {
                    "model_output": "\"Lossless transformation means that no information is lost during the process, so the manipulated image can be perfectly restored to its original state. Examples of lossless transformations include changing the compression format without decompressing and recompressing the image, or applying certain filters that do not alter the underlying pixel data.\"",
                    "blackbox_output": "Creating the gray scale of an image by averaging the amounts of red, green, and blue in each pixel and assigning this new value to the corresponding pixel in the new image. The new value of each pixel represents a shade of gray, ranging from white to black.",
                    "ground_truth": "Creating the negative of an image by creating a new RGB triplet for each pixel in which each value is calculated by subtracting the original value from 255. The negative of an image is reversed from the original; light areas appear dark, and colors are reversed.",
                    "options": "['Compressing the image in a way that may lose information but will suffer only a small loss of image quality.', 'Creating the gray scale of an image by averaging the amounts of red, green, and blue in each pixel and assigning this new value to the corresponding pixel in the new image. The new value of each pixel represents a shade of gray, ranging from white to black.', 'Creating the negative of an image by creating a new RGB triplet for each pixel in which each value is calculated by subtracting the original value from 255. The negative of an image is reversed from the original; light areas appear dark, and colors are reversed.', 'Modifying part of the image by taking the pixels in one part of the picture and copying them to the pixels in another part of the picture.']"
                }
            ]
        },
        "transition_metrics": {
            "agreement_transitions": {
                "zero_agree_few_agree": 0.41,
                "zero_agree_few_disagree": 0.3,
                "zero_disagree_few_agree": 0.13,
                "zero_disagree_few_disagree": 0.16
            },
            "response_length_metrics": {
                "zero_shot": {
                    "surrogate_avg_token_length": 7.8,
                    "blackbox_avg_token_length": 15.4,
                    "agree_avg_combined_length": 18.2,
                    "disagree_avg_combined_length": 35.2
                },
                "few_shot": {
                    "surrogate_avg_token_length": 74.5,
                    "blackbox_avg_token_length": 15.4,
                    "agree_avg_combined_length": 91.2,
                    "disagree_avg_combined_length": 88.3
                }
            },
            "symantic_similarity": {
                "zero_agree_few_agree_cosine_distance": 0.5120127833471065,
                "zero_agree_few_disagree_cosine_distance": 0.3234140588591496,
                "zero_disagree_few_agree_cosine_distance": 0.2686630367086484,
                "zero_disagree_few_disagree_cosine_distance": 0.35355057334527373
            }
        }
    },
    "wrt_blackbox": {
        "exact_match": 0.0,
        "f1_score_token_agreement": 0.11611740427966911,
        "rouge_scores": {
            "rouge1": 0.19457171785509172,
            "rouge2": 0.06056209360914694,
            "rougeL": 0.15442513945511746
        },
        "bleu_score": 0.013488319448195342,
        "sbert_similarity": 0.4540867402218282
    }
}